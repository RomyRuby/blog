import{_ as s,c as n,o as a,a as l}from"./app.2d43daee.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"1.JavaScript有哪些数据类型，它们的区别？","slug":"_1-javascript有哪些数据类型-它们的区别","link":"#_1-javascript有哪些数据类型-它们的区别","children":[]},{"level":3,"title":"2. 数据类型检测的方式有哪些","slug":"_2-数据类型检测的方式有哪些","link":"#_2-数据类型检测的方式有哪些","children":[]},{"level":3,"title":"3. 判断数组的方式有哪些","slug":"_3-判断数组的方式有哪些","link":"#_3-判断数组的方式有哪些","children":[]},{"level":3,"title":"5. typeof null 的结果是什么，为什么？","slug":"_5-typeof-null-的结果是什么-为什么","link":"#_5-typeof-null-的结果是什么-为什么","children":[]},{"level":3,"title":"6. intanceof 操作符的实现原理及实现","slug":"_6-intanceof-操作符的实现原理及实现","link":"#_6-intanceof-操作符的实现原理及实现","children":[]},{"level":3,"title":"7. 为什么0.1+0.2 ! == 0.3，如何让其相等","slug":"_7-为什么0-1-0-2-0-3-如何让其相等","link":"#_7-为什么0-1-0-2-0-3-如何让其相等","children":[]},{"level":3,"title":"8. 如何获取安全的 undefined 值？","slug":"_8-如何获取安全的-undefined-值","link":"#_8-如何获取安全的-undefined-值","children":[]},{"level":3,"title":"9. typeof NaN 的结果是什么？","slug":"_9-typeof-nan-的结果是什么","link":"#_9-typeof-nan-的结果是什么","children":[]},{"level":3,"title":"10. isNaN 和 Number.isNaN 函数的区别？","slug":"_10-isnan-和-number-isnan-函数的区别","link":"#_10-isnan-和-number-isnan-函数的区别","children":[]},{"level":3,"title":"12. 其他值到字符串的转换规则？","slug":"_12-其他值到字符串的转换规则","link":"#_12-其他值到字符串的转换规则","children":[]},{"level":3,"title":"13. 其他值到数字值的转换规则？","slug":"_13-其他值到数字值的转换规则","link":"#_13-其他值到数字值的转换规则","children":[]},{"level":3,"title":"14. 其他值到布尔类型的值的转换规则？","slug":"_14-其他值到布尔类型的值的转换规则","link":"#_14-其他值到布尔类型的值的转换规则","children":[]},{"level":3,"title":"15. || 和 && 操作符的返回值？","slug":"_15-和-操作符的返回值","link":"#_15-和-操作符的返回值","children":[]},{"level":3,"title":"16. Object.is() 与比较操作符 三等、双等的区别？","slug":"_16-object-is-与比较操作符-三等、双等的区别","link":"#_16-object-is-与比较操作符-三等、双等的区别","children":[]},{"level":3,"title":"17. 什么是 JavaScript 中的包装类型？","slug":"_17-什么是-javascript-中的包装类型","link":"#_17-什么是-javascript-中的包装类型","children":[]},{"level":3,"title":"18. JavaScript 中如何进行隐式类型转换？","slug":"_18-javascript-中如何进行隐式类型转换","link":"#_18-javascript-中如何进行隐式类型转换","children":[]},{"level":3,"title":"19. + 操作符什么时候用于字符串的拼接？","slug":"_19-操作符什么时候用于字符串的拼接","link":"#_19-操作符什么时候用于字符串的拼接","children":[]},{"level":3,"title":"20. 为什么会有BigInt的提案？","slug":"_20-为什么会有bigint的提案","link":"#_20-为什么会有bigint的提案","children":[]},{"level":3,"title":"21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别","slug":"_21-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别","link":"#_21-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别","children":[]}],"relativePath":"JavaScript/data-type.md","lastUpdated":1693810075000}'),e={name:"JavaScript/data-type.md"},p=l(`<h3 id="_1-javascript有哪些数据类型-它们的区别" tabindex="-1">1.JavaScript有哪些数据类型，它们的区别？ <a class="header-anchor" href="#_1-javascript有哪些数据类型-它们的区别" aria-hidden="true">#</a></h3><p>原始数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt（存储在栈中）</p><p>引用数据类型：Object（存储在堆中，地址在栈中）</p><h3 id="_2-数据类型检测的方式有哪些" tabindex="-1">2. 数据类型检测的方式有哪些 <a class="header-anchor" href="#_2-数据类型检测的方式有哪些" aria-hidden="true">#</a></h3><ul><li>typeof 其中数组、对象、null都会被判断为object，其他判断都正确。</li><li>instanceof</li><li>constructor</li><li>Object.prototype.toString.call()</li></ul><h3 id="_3-判断数组的方式有哪些" tabindex="-1">3. 判断数组的方式有哪些 <a class="header-anchor" href="#_3-判断数组的方式有哪些" aria-hidden="true">#</a></h3><ul><li><p>通过Object.prototype.toString.call()做判断</p></li><li><p>Array.isArray</p></li><li><p>通过instanceof做判断</p></li></ul><h3 id="_5-typeof-null-的结果是什么-为什么" tabindex="-1">5. typeof null 的结果是什么，为什么？ <a class="header-anchor" href="#_5-typeof-null-的结果是什么-为什么" aria-hidden="true">#</a></h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 数据类型中：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#E06C75;">javascript底层</span></span>
<span class="line"><span style="color:#D19A66;">000</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">object</span><span style="color:#ABB2BF;">   </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">当前存储的数据指向一个对象</span><span style="color:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">int</span><span style="color:#ABB2BF;">      </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">当前存储的数据是一个</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">31</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">位的有符号整数</span><span style="color:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#D19A66;">010</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">double</span><span style="color:#ABB2BF;">   </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">当前存储的数据指向一个双精度的浮点数</span><span style="color:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">string</span><span style="color:#ABB2BF;">   </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">当前存储的数据指向一个字符串</span><span style="color:#ABB2BF;">。</span></span>
<span class="line"><span style="color:#D19A66;">110</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">boolean</span><span style="color:#ABB2BF;">  </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">当前存储的数据是布尔值</span><span style="color:#ABB2BF;">。</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#B392F0;">javascript底层</span></span>
<span class="line"><span style="color:#F8F8F8;">000</span><span style="color:#B392F0;">: object   </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 当前存储的数据指向一个对象。</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F8F8F8;">1</span><span style="color:#B392F0;">: int      </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 当前存储的数据是一个 </span><span style="color:#F8F8F8;">31</span><span style="color:#B392F0;"> 位的有符号整数。</span></span>
<span class="line"><span style="color:#F8F8F8;">010</span><span style="color:#B392F0;">: double   </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 当前存储的数据指向一个双精度的浮点数。</span></span>
<span class="line"><span style="color:#F8F8F8;">100</span><span style="color:#B392F0;">: string   </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 当前存储的数据指向一个字符串。</span></span>
<span class="line"><span style="color:#F8F8F8;">110</span><span style="color:#B392F0;">: boolean  </span><span style="color:#F97583;">-</span><span style="color:#B392F0;"> 当前存储的数据是布尔值。</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="_6-intanceof-操作符的实现原理及实现" tabindex="-1">6. intanceof 操作符的实现原理及实现 <a class="header-anchor" href="#_6-intanceof-操作符的实现原理及实现" aria-hidden="true">#</a></h3><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">myInstanceof</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">left</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">right</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 获取对象的原型</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">proto</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getPrototypeOf</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">left</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 获取构造函数的 prototype 对象</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">right</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">; </span></span>
<span class="line"><span style="color:#ABB2BF;"> </span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">while</span><span style="color:#ABB2BF;"> (</span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E06C75;">proto</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">proto</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">===</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">prototype</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E06C75;">proto</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getPrototypeOf</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">proto</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> myInstanceof(left</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> right) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 获取对象的原型</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> proto </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#B392F0;">.getPrototypeOf(left)</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 获取构造函数的 prototype 对象</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">let</span><span style="color:#B392F0;"> prototype </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">right</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#B392F0;">; </span></span>
<span class="line"><span style="color:#B392F0;"> </span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">while</span><span style="color:#B392F0;"> (</span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">proto) </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">false</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (proto </span><span style="color:#F97583;">===</span><span style="color:#B392F0;"> prototype) </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">true</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span>
<span class="line"><span style="color:#B392F0;">    proto </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#B392F0;">.getPrototypeOf(proto);</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_7-为什么0-1-0-2-0-3-如何让其相等" tabindex="-1">7. 为什么0.1+0.2 ! == 0.3，如何让其相等 <a class="header-anchor" href="#_7-为什么0-1-0-2-0-3-如何让其相等" aria-hidden="true">#</a></h3><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>用tofixed解决</p><h3 id="_8-如何获取安全的-undefined-值" tabindex="-1">8. 如何获取安全的 undefined 值？ <a class="header-anchor" href="#_8-如何获取安全的-undefined-值" aria-hidden="true">#</a></h3><p>viod 0</p><h3 id="_9-typeof-nan-的结果是什么" tabindex="-1">9. typeof NaN 的结果是什么？ <a class="header-anchor" href="#_9-typeof-nan-的结果是什么" aria-hidden="true">#</a></h3><p>number</p><h3 id="_10-isnan-和-number-isnan-函数的区别" tabindex="-1">10. isNaN 和 Number.isNaN 函数的区别？ <a class="header-anchor" href="#_10-isnan-和-number-isnan-函数的区别" aria-hidden="true">#</a></h3><ul><li>isNaN ，会类型转换，再比较。</li><li>Number.isNaN ，不会类型转换，非数字直接返回false</li></ul><h3 id="_12-其他值到字符串的转换规则" tabindex="-1">12. 其他值到字符串的转换规则？ <a class="header-anchor" href="#_12-其他值到字符串的转换规则" aria-hidden="true">#</a></h3><ul><li>Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</li><li>Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如&quot;[object Object]&quot;。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="_13-其他值到数字值的转换规则" tabindex="-1">13. 其他值到数字值的转换规则？ <a class="header-anchor" href="#_13-其他值到数字值的转换规则" aria-hidden="true">#</a></h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="_14-其他值到布尔类型的值的转换规则" tabindex="-1">14. 其他值到布尔类型的值的转换规则？ <a class="header-anchor" href="#_14-其他值到布尔类型的值的转换规则" aria-hidden="true">#</a></h3><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • &quot;&quot;</p><p>其余为true</p><h3 id="_15-和-操作符的返回值" tabindex="-1">15. || 和 &amp;&amp; 操作符的返回值？ <a class="header-anchor" href="#_15-和-操作符的返回值" aria-hidden="true">#</a></h3><ul><li>||返回第一个true，否则返回第二个</li><li>&amp;&amp;返回最后一个true，否则返回第一个</li></ul><h3 id="_16-object-is-与比较操作符-三等、双等的区别" tabindex="-1">16. <a href="http://Object.is" target="_blank" rel="noreferrer">Object.is</a>() 与比较操作符 三等、双等的区别？ <a class="header-anchor" href="#_16-object-is-与比较操作符-三等、双等的区别" aria-hidden="true">#</a></h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 <a href="http://Object.is" target="_blank" rel="noreferrer">Object.is</a> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="_17-什么是-javascript-中的包装类型" tabindex="-1">17. 什么是 JavaScript 中的包装类型？ <a class="header-anchor" href="#_17-什么是-javascript-中的包装类型" aria-hidden="true">#</a></h3><p>基本类型拥有了属性，包装成了对象。</p><h3 id="_18-javascript-中如何进行隐式类型转换" tabindex="-1">18. JavaScript 中如何进行隐式类型转换？ <a class="header-anchor" href="#_18-javascript-中如何进行隐式类型转换" aria-hidden="true">#</a></h3><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code-dark"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* </span><span style="color:#C678DD;font-style:italic;">@obj</span><span style="color:#7F848E;font-style:italic;"> 需要转换的对象</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* </span><span style="color:#C678DD;font-style:italic;">@type</span><span style="color:#7F848E;font-style:italic;"> 期望的结果类型</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*/</span></span>
<span class="line"><span style="color:#61AFEF;">ToPrimitive</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">type</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light"><code><span class="line"><span style="color:#6B737C;">/**</span></span>
<span class="line"><span style="color:#6B737C;">* </span><span style="color:#F97583;">@obj</span><span style="color:#6B737C;"> 需要转换的对象</span></span>
<span class="line"><span style="color:#6B737C;">* </span><span style="color:#F97583;">@type</span><span style="color:#6B737C;"> 期望的结果类型</span></span>
<span class="line"><span style="color:#6B737C;">*/</span></span>
<span class="line"><span style="color:#B392F0;">ToPrimitive(obj</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;">type)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>发生转换的情况：</p><p>+：有字符转为string，否则转为数字</p><p>-、*、/、==、&lt;、&gt;：转为数字</p><h3 id="_19-操作符什么时候用于字符串的拼接" tabindex="-1">19. <code>+</code> 操作符什么时候用于字符串的拼接？ <a class="header-anchor" href="#_19-操作符什么时候用于字符串的拼接" aria-hidden="true">#</a></h3><p>+两边有字符或字符串的时候。</p><h3 id="_20-为什么会有bigint的提案" tabindex="-1">20. 为什么会有<strong>BigInt</strong>的提案？ <a class="header-anchor" href="#_20-为什么会有bigint的提案" aria-hidden="true">#</a></h3><p>用来解决JavaScript中超出最⼤安全数字会精度丢失的问题。</p><h3 id="_21-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别" tabindex="-1">21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别 <a class="header-anchor" href="#_21-object-assign和扩展运算法是深拷贝还是浅拷贝-两者区别" aria-hidden="true">#</a></h3><p>都是浅拷贝。</p><ul><li>Object.assign()拷贝到第一个对象中</li><li>扩展操作符（…）拷贝到新的对象中</li></ul>`,59),o=[p];function t(r,c,i,B,y,d){return a(),n("div",null,o)}const h=s(e,[["render",t]]);export{u as __pageData,h as default};
